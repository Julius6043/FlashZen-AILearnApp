
'use client';

import * as React from 'react';
import type { FlashcardType, QuizQuestionType as AIQuizQuestionType } from '@/types';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { CheckCircle2, XCircle, Info, Lightbulb, RotateCcw, Settings } from 'lucide-react';
import { cn } from '@/lib/utils';

interface QuizTabProps {
  flashcards: FlashcardType[];
  aiQuizQuestions: AIQuizQuestionType[];
}

interface QuizDisplayQuestion {
  id: string;
  question: string;
  options: string[];
  correctAnswer: string;
}

function shuffleArray<T>(array: T[]): T[] {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

export function QuizTab({ flashcards, aiQuizQuestions }: QuizTabProps) {
  const [quizDisplayQuestions, setQuizDisplayQuestions] = React.useState<QuizDisplayQuestion[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);
  const [selectedAnswer, setSelectedAnswer] = React.useState<string | null>(null);
  const [isAnswered, setIsAnswered] = React.useState(false);
  const [score, setScore] = React.useState(0);
  const [quizCompleted, setQuizCompleted] = React.useState(false);
  const [isLoadingQuiz, setIsLoadingQuiz] = React.useState(true);

  const [numAutoQuizQuestionsInput, setNumAutoQuizQuestionsInput] = React.useState("5");
  const [quizMode, setQuizMode] = React.useState<'ai_direct' | 'auto_config' | 'auto_active' | 'empty'>('empty');


  const generateAutoQuiz = (numQuestions: number) => {
    if (flashcards.length < 2) return [];
    const questionsToGenerate = Math.min(numQuestions, flashcards.length);
    const shuffledFlashcards = shuffleArray(flashcards);
    
    return shuffledFlashcards.slice(0, questionsToGenerate).map((card) => {
      const otherAnswers = flashcards
        .filter(fc => fc.id !== card.id)
        .map(fc => fc.answer);
      
      let incorrectOptions = shuffleArray(otherAnswers).slice(0, 3);
      const potentialOptions = [...new Set(otherAnswers)]; 
      while (incorrectOptions.length < 3 && incorrectOptions.length < potentialOptions.length) {
        const nextOption = potentialOptions.find(opt => !incorrectOptions.includes(opt) && opt !== card.answer);
        if (nextOption) incorrectOptions.push(nextOption); else break;
      }
      let i = 0;
      while (incorrectOptions.length < 3 && incorrectOptions.length > 0) {
          incorrectOptions.push(incorrectOptions[i % incorrectOptions.length] + (incorrectOptions.length < 2 && i > 0 ? ` ${i+1}`: "")); // Add slight variation if duplicating
          i++;
      }
      const uniqueOptions = [...new Set([card.answer, ...incorrectOptions])];
      return {
        id: card.id,
        question: card.question,
        options: shuffleArray(uniqueOptions.slice(0,4)), // Ensure max 4 options
        correctAnswer: card.answer,
      };
    });
  };

  React.useEffect(() => {
    setIsLoadingQuiz(true);
    if (aiQuizQuestions && aiQuizQuestions.length > 0) {
      setQuizDisplayQuestions(aiQuizQuestions.map(q => ({ ...q, options: shuffleArray(q.options) })));
      setQuizMode('ai_direct');
    } else if (flashcards.length >= 2) {
      setQuizMode('auto_config');
    } else {
      setQuizMode('empty');
      setQuizDisplayQuestions([]);
    }
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setIsAnswered(false);
    setScore(0);
    setQuizCompleted(false);
    setIsLoadingQuiz(false);
  }, [flashcards, aiQuizQuestions]);

  const handleStartAutoQuiz = () => {
    const num = parseInt(numAutoQuizQuestionsInput, 10);
    if (isNaN(num) || num < 1 || num > flashcards.length) {
      // Basic validation, can add toast later
      alert(`Please enter a number between 1 and ${flashcards.length}.`);
      return;
    }
    const autoGenerated = generateAutoQuiz(num);
    setQuizDisplayQuestions(shuffleArray(autoGenerated));
    setQuizMode('auto_active');
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setIsAnswered(false);
    setScore(0);
    setQuizCompleted(false);
  };

  if (isLoadingQuiz) {
    return <div className="text-center p-10">Preparing your quiz... <Lightbulb className="inline h-5 w-5 animate-pulse" /></div>;
  }
  
  if (quizMode === 'empty') {
    return (
     <Alert>
       <Info className="h-4 w-4" />
       <AlertTitle>Not Enough Content for Quiz</AlertTitle>
       <AlertDescription>
         You need at least 2 flashcards to start a multiple-choice quiz if no AI questions are provided. Please generate more flashcards or ensure AI generates quiz questions.
       </AlertDescription>
     </Alert>
   );
 }

  if (quizMode === 'auto_config') {
    return (
      <Card className="w-full max-w-md mx-auto shadow-lg">
        <CardHeader>
          <CardTitle className="flex items-center gap-2"><Settings className="h-6 w-6 text-primary"/>Configure Quiz</CardTitle>
          <CardDescription>Set up your quiz generated from flashcards.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="num-auto-quiz">Number of Questions (1-{flashcards.length})</Label>
            <Input 
              id="num-auto-quiz"
              type="number"
              value={numAutoQuizQuestionsInput}
              onChange={(e) => setNumAutoQuizQuestionsInput(e.target.value)}
              min={1}
              max={flashcards.length}
              className="mt-1"
            />
          </div>
        </CardContent>
        <CardFooter>
          <Button onClick={handleStartAutoQuiz} className="w-full">Start Quiz</Button>
        </CardFooter>
      </Card>
    );
  }


  if (quizDisplayQuestions.length === 0 && (quizMode === 'ai_direct' || quizMode === 'auto_active')) {
    return (
     <Alert variant="destructive">
       <Info className="h-4 w-4" />
       <AlertTitle>Quiz Generation Failed</AlertTitle>
       <AlertDescription>
         Could not generate quiz questions. AI might have returned empty or invalid data, or there were too few flashcards for auto-generation.
       </AlertDescription>
     </Alert>
   );
  }

  const currentQuestion = quizDisplayQuestions[currentQuestionIndex];

  const handleAnswerSelect = (answer: string) => {
    if (isAnswered) return;
    setSelectedAnswer(answer);
    setIsAnswered(true);
    if (answer === currentQuestion.correctAnswer) {
      setScore(prevScore => prevScore + 1);
    }
  };

  const handleNextQuestion = () => {
    if (currentQuestionIndex < quizDisplayQuestions.length - 1) {
      setCurrentQuestionIndex(prevIndex => prevIndex + 1);
      setSelectedAnswer(null);
      setIsAnswered(false);
    } else {
      setQuizCompleted(true);
    }
  };
  
  const handleRestartQuiz = () => {
    if (quizMode === 'ai_direct') {
      setQuizDisplayQuestions(prevQuestions => shuffleArray(prevQuestions.map(q => ({...q, options: shuffleArray(q.options.slice()) }))));
    } else { // 'auto_active' or if we want to re-config 'auto_config'
       setQuizMode('auto_config'); // Go back to config screen for auto-quiz
       setQuizDisplayQuestions([]); // Clear current questions
    }
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setIsAnswered(false);
    setScore(0);
    setQuizCompleted(false);
  };


  if (quizCompleted) {
    return (
      <Card className="w-full max-w-2xl mx-auto text-center shadow-xl">
        <CardHeader>
          <CardTitle className="text-2xl">Quiz Completed!</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-xl">Your Score: <span className="font-bold text-primary">{score}</span> / {quizDisplayQuestions.length}</p>
          <Progress value={(score / quizDisplayQuestions.length) * 100} className="w-full h-3" />
          <p className="text-muted-foreground">
            {score === quizDisplayQuestions.length ? "Perfect score! ðŸŽ‰" : "Keep practicing to improve!"}
          </p>
        </CardContent>
        <CardFooter>
          <Button onClick={handleRestartQuiz} className="w-full" variant="default">
            <RotateCcw className="mr-2 h-4 w-4" /> Restart Quiz
          </Button>
        </CardFooter>
      </Card>
    );
  }

  if (!currentQuestion) { 
      return <div className="text-center p-10">Error loading current question.</div>;
  }

  return (
    <Card className="w-full max-w-2xl mx-auto shadow-xl">
      <CardHeader>
        <CardTitle className="text-xl md:text-2xl">Question {currentQuestionIndex + 1} of {quizDisplayQuestions.length}</CardTitle>
        <CardDescription className="text-base pt-4 min-h-[60px] break-words">{currentQuestion.question}</CardDescription>
        <Progress value={((currentQuestionIndex + 1) / quizDisplayQuestions.length) * 100} className="w-full h-2 mt-2" />
      </CardHeader>
      <CardContent className="space-y-3">
        {currentQuestion.options.map((option, index) => {
          const isCorrectOption = option === currentQuestion.correctAnswer;
          const isSelected = option === selectedAnswer;
          let buttonVariant: "default" | "outline" | "secondary" | "destructive" | "ghost" | "link" = "outline";
          let icon = null;

          if (isAnswered) {
            if (isCorrectOption) {
              buttonVariant = "secondary"; 
              icon = <CheckCircle2 className="h-5 w-5 text-green-500" />;
            } else if (isSelected && !isCorrectOption) {
              buttonVariant = "destructive"; 
              icon = <XCircle className="h-5 w-5" />;
            }
          }
          
          return (
            <Button
              key={`${currentQuestion.id}-option-${index}`}
              variant={buttonVariant}
              className={cn(
                "w-full justify-start text-left h-auto py-3 px-4 rounded-md transition-all duration-150 ease-in-out",
                "hover:bg-accent/50 hover:text-accent-foreground",
                isSelected && !isAnswered && "ring-2 ring-primary ring-offset-1",
                isAnswered && isCorrectOption && "bg-green-500/20 border-green-500 text-green-700 dark:text-green-300 dark:border-green-600 dark:bg-green-700/30 hover:bg-green-500/30",
                isAnswered && isSelected && !isCorrectOption && "bg-red-500/20 border-red-500 text-red-700 dark:text-red-300 dark:border-red-600 dark:bg-red-700/30 hover:bg-red-500/30"
              )}
              onClick={() => handleAnswerSelect(option)}
              disabled={isAnswered}
              aria-label={`Option: ${option}${isSelected ? ", selected" : ""}${isAnswered && isCorrectOption ? ", correct" : ""}${isAnswered && isSelected && !isCorrectOption ? ", incorrect" : ""}`}
            >
              {icon && <span className="mr-2 shrink-0">{icon}</span>}
              <span className="flex-1 whitespace-normal break-words">{option}</span>
            </Button>
          );
        })}
      </CardContent>
      <CardFooter className="flex flex-col items-center gap-4">
        {isAnswered && (
          <div className="w-full p-3 rounded-md text-center font-semibold">
            {selectedAnswer === currentQuestion.correctAnswer ? (
              <p className="text-green-600 dark:text-green-400 flex items-center justify-center"><CheckCircle2 className="mr-2"/> Correct!</p>
            ) : (
              <p className="text-red-600 dark:text-red-400 flex flex-col sm:flex-row items-center justify-center gap-1">
                <span className="flex items-center"><XCircle className="mr-2"/> Incorrect.</span>
                <span>Correct answer: <strong className="ml-1">{currentQuestion.correctAnswer}</strong></span>
              </p>
            )}
          </div>
        )}
        <Button 
          onClick={handleNextQuestion} 
          disabled={!isAnswered} 
          className="w-full shadow-md hover:shadow-lg transition-shadow"
        >
          {currentQuestionIndex === quizDisplayQuestions.length - 1 ? 'Finish Quiz' : 'Next Question'}
        </Button>
         <p className="text-sm text-muted-foreground">Score: {score} / {quizDisplayQuestions.length}</p>
      </CardFooter>
    </Card>
  );
}
